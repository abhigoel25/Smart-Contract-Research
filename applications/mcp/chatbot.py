"""
Chatbot for interacting with generated MCP contract servers.

This chatbot bridges the gap between user natural language requests and the
MCP servers generated by agentic_implementation.py. It uses OpenAI's LLM
to understand what the user wants and translate that into specific MCP tool calls.
"""

import os
import asyncio
import json
import sys
from fastmcp import Client
from dotenv import load_dotenv
import re
from pathlib import Path

# Add parent directory to path to import agentic_implementation
sys.path.insert(0, str(Path(__file__).parent.parent / "contract-translator"))

from agentics import LLM, user_message, system_message

# --- Load environment variables ---
load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise RuntimeError("OPENAI_API_KEY not found in .env")

# --- Initialize IBM Agentics LLM with OpenAI ---
llm = LLM(model="gpt-4o-mini")
print("âœ“ OpenAI LLM initialized with gpt-4o-mini")

# --- MCP Client for calling smart contract tools ---
mcp_client = None


async def decide_tool_call(user_input: str, tools: list, contract_type: str) -> dict:
    """
    Use LLM to decide which tool to call based on user input.
    
    Args:
        user_input: What the user wants to do
        tools: Available MCP tools from the server
        contract_type: Type of contract (for context)
    
    Returns:
        dict: {"tool": tool_name, "args": {...}} or {"error": message}
    """
    
    # Convert Tool objects to dict format for description
    tool_descriptions = []
    for t in tools:
        # Handle both Tool objects and dicts
        if hasattr(t, 'name'):
            name = t.name
            desc = t.description if hasattr(t, 'description') else 'No description'
        else:
            name = t.get('name', 'unknown')
            desc = t.get('description', 'No description')
        tool_descriptions.append(f"- {name}: {desc}")
    
    tool_descriptions_str = "\n".join(tool_descriptions)
    
    messages = [
        system_message(
            f"""You are an AI assistant managing a {contract_type} smart contract.
            
Your job is to understand what the user wants and decide which contract tool to call.

Available tools:
{tool_descriptions_str}

When the user makes a request, respond with ONLY valid JSON (no explanations or markdown).
Format: {{"tool": "function_name", "args": {{"param1": value1, "param2": value2}}}}

Common requests:
- "What's the status?" â†’ call a status/view function
- "Pay rent" â†’ call a payRent() type function
- "Deposit security" â†’ call depositSecurityDeposit() type function
- "Terminate contract" â†’ call a terminate/end function

Always use actual function names from the available tools."""
        ),
        user_message(
            f"""User request: "{user_input}"

Respond with ONLY the JSON, no extra text."""
        )
    ]
    
    response = llm.chat(messages=messages)
    response_text = str(response).strip()
    
    # Remove markdown fences if present
    if "```json" in response_text:
        response_text = response_text.split("```json")[1].split("```")[0].strip()
    elif "```" in response_text:
        response_text = response_text.split("```")[1].split("```")[0].strip()
    
    try:
        result = json.loads(response_text)
        return result
    except Exception as e:
        return {"error": f"Invalid JSON from LLM: {response_text}", "exception": str(e)}


async def run_mcp_server_chatbot(mcp_server_path: str, contract_name: str, contract_type: str):
    """
    Run interactive chatbot for a specific MCP contract server.
    
    Args:
        mcp_server_path: Path to the generated MCP server script
        contract_name: Name of the contract (for display)
        contract_type: Type of contract (rental, employment, etc.)
    """
    
    global mcp_client
    
    print(f"\n{'='*70}")
    print(f"CONTRACT CHATBOT: {contract_name} ({contract_type})")
    print(f"{'='*70}")
    print(f"MCP Server: {mcp_server_path}")
    print("Type 'quit' to exit, 'status' for contract status\n")
    
    # Connect to MCP server
    try:
        mcp_client = Client(mcp_server_path)
        async with mcp_client:
            # Get available tools
            tools = await mcp_client.list_tools()
            print(f"âœ“ Connected to MCP server")
            print(f"âœ“ Available functions: {len(tools)}\n")
            
            # Print available tools
            print("Available contract functions:")
            for tool in tools[:5]:  # Show first 5
                # Handle both Tool objects and dicts
                if hasattr(tool, 'name'):
                    print(f"  - {tool.name}")
                else:
                    print(f"  - {tool.get('name', 'unknown')}")
            if len(tools) > 5:
                print(f"  ... and {len(tools) - 5} more")
            print()
            
            # Main chat loop
            while True:
                try:
                    user_input = input("You: ").strip()
                except EOFError:
                    break
                
                if user_input.lower() in ["quit", "exit"]:
                    print("Goodbye!")
                    break
                
                if not user_input:
                    continue
                
                # Special case: status command
                if user_input.lower() == "status":
                    print("\nFetching contract status...\n")
                    for tool in tools:
                        # Handle both Tool objects and dicts
                        if hasattr(tool, 'name'):
                            tool_name = tool.name
                            desc = tool.description if hasattr(tool, 'description') else ''
                        else:
                            tool_name = tool.get('name', 'unknown')
                            desc = tool.get('description', '')
                        
                        if "status" in tool_name.lower() or "view" in desc.lower():
                            try:
                                result = await mcp_client.call_tool(tool_name, {})
                                print(f"[{tool_name}] {result}\n")
                            except Exception as e:
                                print(f"Error calling {tool_name}: {e}\n")
                    continue
                
                # Use LLM to decide which tool to call
                print("\nðŸ¤– Analyzing request...")
                decision = await decide_tool_call(user_input, tools, contract_type)
                
                if "error" in decision:
                    print(f"âŒ {decision['error']}\n")
                    continue
                
                tool_name = decision.get("tool")
                args = decision.get("args", {})
                
                if not tool_name:
                    print("âŒ Could not determine which tool to call\n")
                    continue
                
                print(f"ðŸ“ž Calling: {tool_name}({json.dumps(args)})")
                
                # Call the MCP tool
                try:
                    result = await mcp_client.call_tool(tool_name, args)
                    print(f"âœ… Success: {result}\n")
                except Exception as e:
                    print(f"âŒ Failed: {e}\n")
    
    except Exception as e:
        print(f"âŒ Failed to connect to MCP server: {e}")
        return


async def interactive_mode():
    """
    Interactive mode: Ask user which contract to interact with.
    """
    
    print("\n" + "="*70)
    print("SMART CONTRACT CHATBOT")
    print("="*70)
    print("\nThis chatbot helps you interact with AI-generated smart contracts.")
    print("You can interact with any MCP server generated by agentic_implementation.py\n")
    
    # Ask user for MCP server path
    while True:
        mcp_path = input("Enter path to MCP server file (e.g., ./output/Investment_Agreement_1/BlockChain_Venture_Ca_mcp_server.py): ").strip()
        
        if mcp_path.lower() in ["quit", "exit"]:
            return
        
        if not Path(mcp_path).exists():
            print(f"âŒ File not found: {mcp_path}\n")
            continue
        
        # Extract contract name from path
        contract_name = Path(mcp_path).stem.replace("_mcp_server", "")
        
        # Extract contract type from parent directory
        parent_dir = Path(mcp_path).parent.name
        contract_type = parent_dir.replace("_1", "").replace("_2", "").replace("_3", "").replace("_4", "").replace("_5", "")
        
        await run_mcp_server_chatbot(mcp_path, contract_name, contract_type)
        
        # Ask if they want to try another contract
        again = input("\nConnect to another MCP server? (yes/no): ").strip().lower()
        if again not in ["yes", "y"]:
            break
    
    print("\nGoodbye!")


def main():
    """Main entry point"""
    
    print("IBM Agentics - Contract Chatbot")
    print("=" * 70)
    
    # Check for command line arguments
    if len(sys.argv) > 1:
        # Direct MCP server path provided
        mcp_server_path = sys.argv[1]
        contract_name = Path(mcp_server_path).stem.replace("_mcp_server", "")
        parent_dir = Path(mcp_server_path).parent.name
        contract_type = parent_dir.split("_")[:-1]  # Remove the number at end
        contract_type = "_".join(contract_type)
        
        asyncio.run(run_mcp_server_chatbot(mcp_server_path, contract_name, contract_type))
    else:
        # Interactive mode
        asyncio.run(interactive_mode())


if __name__ == "__main__":
    main()
